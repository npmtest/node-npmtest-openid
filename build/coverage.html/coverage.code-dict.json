{"/home/travis/build/npmtest/node-npmtest-openid/test.js":"/* istanbul instrument in package npmtest_openid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid/lib.npmtest_openid.js":"/* istanbul instrument in package npmtest_openid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_openid = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_openid = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-openid/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-openid && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_openid */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_openid\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_openid.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_openid.rollup.js'] =\n            local.assetsDict['/assets.npmtest_openid.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_openid.__dirname + '/lib.npmtest_openid.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-openid/node_modules/openid/openid.js":"/* OpenID for node.js\n *\n * http://ox.no/software/node-openid\n * http://github.com/havard/node-openid\n *\n * Copyright (C) 2010 by Håvard Stranden\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *\n * -*- Mode: JS; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- \n * vim: set sw=2 ts=2 et tw=80 : \n */\n\nvar Buffer = require('buffer').Buffer,\n    crypto = require('crypto'),\n    request = require('request'),\n    querystring = require('querystring'),\n    url = require('url'),\n    xrds = require('./lib/xrds');\n\nvar _associations = {};\nvar _discoveries = {};\nvar _nonces = {};\n\nvar AX_MAX_VALUES_COUNT = 1000;\n\nvar openid = exports;\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nopenid.RelyingParty = function(returnUrl, realm, stateless, strict, extensions)\n{\n  this.returnUrl = returnUrl;\n  this.realm = realm || null;\n  this.stateless = stateless;\n  this.strict = strict;\n  this.extensions = extensions;\n}\n\nopenid.RelyingParty.prototype.authenticate = function(identifier, immediate, callback)\n{\n  openid.authenticate(identifier, this.returnUrl, this.realm, \n      immediate, this.stateless, callback, this.extensions, this.strict);\n}\n\nopenid.RelyingParty.prototype.verifyAssertion = function(requestOrUrl, callback)\n{\n  openid.verifyAssertion(requestOrUrl, this.returnUrl, callback, this.stateless, this.extensions, this.strict);\n}\n\n\n\nvar _btwoc = function(i)\n{\n  if(i.charCodeAt(0) > 127)\n  {\n    return String.fromCharCode(0) + i;\n  }\n  return i;\n}\n\nvar _unbtwoc = function(i)\n{\n  if(i[0] === String.fromCharCode(0))\n  {\n    return i.substr(1);\n  }\n\n  return i;\n}\n\nvar _isDef = function(e)\n{\n  var undefined;\n  return e !== undefined;\n}\n\n// Find the most up-to-date and usable way to create buffers\nvar _buffer = null;\nif (typeof(Buffer.from) === 'function') {\n  // Some older Node versions throw an exception when \n  // buffers with binary encoding are created using the\n  // from function, so if that happens we have to resort\n  // to constructor based creation.\n  try {\n    Buffer.from('openid', 'binary');\n    _buffer = Buffer.from;\n  }\n  catch(_) {\n  }\n}\nif (_buffer === null) {\n  // Either the Node version is too old to have a Buffer.from,\n  // or the Buffer.from call failed with binary encoding.\n  // Either way, use the (deprecated from node v6) constructor.\n  _buffer = function(str, enc) { return new Buffer(str, enc); };\n} \n\nvar _base64encode = function(str) {\n  return _buffer(str, 'binary').toString('base64');\n};\n\nvar _base64decode = function(str) {\n  return _buffer(str, 'base64').toString('binary');\n};\n\nvar _bigIntToBase64 = function(binary)\n{\n  return _base64encode(_btwoc(binary));  \n}\n\nvar _bigIntFromBase64 = function(str)\n{\n  return _unbtwoc(_base64decode(str));\n}\n\nvar _xor = function(a, b)\n{\n  if(a.length != b.length)\n  {\n    throw new Error('Length must match for xor');\n  }\n\n  var r = '';\n  for(var i = 0; i < a.length; ++i)\n  {\n    r += String.fromCharCode(a.charCodeAt(i) ^ b.charCodeAt(i));\n  }\n\n  return r;\n}\n\nopenid.saveAssociation = function(provider, type, handle, secret, expiry_time_in_seconds, callback)\n{\n  setTimeout(function() {\n    openid.removeAssociation(handle);\n  }, expiry_time_in_seconds * 1000);\n  _associations[handle] = {provider: provider, type : type, secret: secret};\n  callback(null); // Custom implementations may report error as first argument\n}\n\nopenid.loadAssociation = function(handle, callback)\n{\n  if(_isDef(_associations[handle]))\n  {\n    callback(null, _associations[handle]);\n  }\n  else\n  {\n    callback(null, null);\n  }\n}\n\nopenid.removeAssociation = function(handle)\n{\n  delete _associations[handle];\n  return true;\n}\n\nopenid.saveDiscoveredInformation = function(key, provider, callback)\n{\n  _discoveries[key] = provider;\n  return callback(null);\n}\n\nopenid.loadDiscoveredInformation = function(key, callback)\n{\n  if(!_isDef(_discoveries[key]))\n  {\n    return callback(null, null);\n  }\n\n  return callback(null, _discoveries[key]);\n}\n\nvar _buildUrl = function(theUrl, params)\n{\n  theUrl = url.parse(theUrl, true);\n  delete theUrl['search'];\n  if(params)\n  {\n    if(!theUrl.query)\n    {\n      theUrl.query = params;\n    }\n    else\n    {\n      for(var key in params)\n      {\n        if(hasOwnProperty(params, key))\n        {\n          theUrl.query[key] = params[key];\n        }\n      }\n    }\n  }\n\n  return url.format(theUrl);\n}\n\nvar _get = function (getUrl, params, callback, redirects) {\n  var options = {\n    url: getUrl,\n    maxRedirects: redirects || 5,\n    qs: params,\n    headers: { 'Accept' : 'application/xrds+xml,text/html,text/plain,*/*;q=0.9' }\n  };\n  request.get(options, function (error, response, body) {\n    if (error) {\n      callback(error);\n    } else {\n      callback(body, response.headers, response.statusCode);\n    }\n  });\n};\n\nvar _post = function (postUrl, data, callback, redirects) {\n  var options = {\n    url: postUrl,\n    maxRedirects: redirects || 5,\n    form: data,\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n  };\n  request.post(options, function (error, response, body) {\n    if (error) {\n      callback(error);\n    } else {\n      callback(body, response.headers, response.statusCode);\n    }\n  });\n};\n\nvar _decodePostData = function(data)\n{\n  var lines = data.split('\\n');\n  var result = {};\n  for (var i = 0; i < lines.length ; i++) {\n    var line = lines[i];\n    if (line.length > 0 && line[line.length - 1] == '\\r') {\n      line = line.substring(0, line.length - 1);\n    }\n    var colon = line.indexOf(':');\n    if (colon === -1)\n    {\n      continue;\n    }\n    var key = line.substr(0, line.indexOf(':'));\n    var value = line.substr(line.indexOf(':') + 1);\n    result[key] = value;\n  }\n\n  return result;\n}\n\nvar _normalizeIdentifier = function(identifier)\n{\n  identifier = identifier.replace(/^\\s+|\\s+$/g, '');\n  if(!identifier)\n    return null;\n  if(identifier.indexOf('xri://') === 0)\n  {\n    identifier = identifier.substring(6);\n  }\n\n  if(/^[(=@\\+\\$!]/.test(identifier))\n  {\n    return identifier;\n  }\n\n  if(identifier.indexOf('http') === 0)\n  {\n    return identifier;\n  }\n  return 'http://' + identifier;\n}\n\nvar _parseXrds = function(xrdsUrl, xrdsData)\n{\n  var services = xrds.parse(xrdsData);\n  if(services == null)\n  {\n    return null;\n  }\n\n  var providers = [];\n  for(var i = 0, len = services.length; i < len; ++i)\n  {\n    var service = services[i];\n    var provider = {};\n\n    provider.endpoint = service.uri;\n    if(/https?:\\/\\/xri./.test(xrdsUrl))\n    {\n      provider.claimedIdentifier = service.id;\n    }\n    if(service.type == 'http://specs.openid.net/auth/2.0/signon')\n    {\n      provider.version = 'http://specs.openid.net/auth/2.0';\n      provider.localIdentifier = service.id;\n    }\n    else if(service.type == 'http://specs.openid.net/auth/2.0/server')\n    {\n      provider.version = 'http://specs.openid.net/auth/2.0';\n    }\n    else if(service.type == 'http://openid.net/signon/1.0' || \n      service.type == 'http://openid.net/signon/1.1')\n    {\n      provider.version = service.type;\n      provider.localIdentifier = service.delegate;\n    }\n    else\n    {\n      continue;\n    }\n    providers.push(provider);\n  }\n\n  return providers;\n}\n\nvar _matchMetaTag = function(html)\n{\n  var metaTagMatches = /<meta\\s+.*?http-equiv=\"x-xrds-location\"\\s+(.*?)>/ig.exec(html);\n  if(!metaTagMatches || metaTagMatches.length < 2)\n  {\n    return null;\n  }\n\n  var contentMatches = /content=\"(.*?)\"/ig.exec(metaTagMatches[1]);\n  if(!contentMatches || contentMatches.length < 2)\n  {\n    return null;\n  }\n\n  return contentMatches[1];\n}\n\nvar _matchLinkTag = function(html, rel)\n{\n  var providerLinkMatches = new RegExp('<link\\\\s+.*?rel=[\"\\'][^\"\\']*?' + rel + '[^\"\\']*?[\"\\'].*?>', 'ig').exec(html);\n\n  if(!providerLinkMatches || providerLinkMatches.length < 1)\n  {\n    return null;\n  }\n\n  var href = /href=[\"'](.*?)[\"']/ig.exec(providerLinkMatches[0]);\n\n  if(!href || href.length < 2)\n  {\n    return null;\n  }\n  return href[1];\n}\n\nvar _parseHtml = function(htmlUrl, html, callback, hops)\n{\n  var metaUrl = _matchMetaTag(html);\n  if(metaUrl != null)\n  {\n    return _resolveXri(metaUrl, callback, hops + 1);\n  }\n\n  var provider = _matchLinkTag(html, 'openid2.provider');\n  if(provider == null)\n  {\n    provider = _matchLinkTag(html, 'openid.server');\n    if(provider == null)\n    {\n      callback(null);\n    }\n    else\n    {\n      var localId = _matchLinkTag(html, 'openid.delegate');\n      callback([{ \n        version: 'http://openid.net/signon/1.1',\n        endpoint: provider, \n        claimedIdentifier: htmlUrl,\n        localIdentifier : localId \n      }]);\n    }\n  }\n  else\n  {\n    var localId = _matchLinkTag(html, 'openid2.local_id');\n    callback([{ \n      version: 'http://specs.openid.net/auth/2.0/signon', \n      endpoint: provider, \n      claimedIdentifier: htmlUrl,\n      localIdentifier : localId \n    }]);\n  }\n}\n\nvar _parseHostMeta = function(hostMeta, callback)\n{\n  var match = /^Link: <([^\\n\\r]+?)>;/.exec(hostMeta);\n  if (match != null && match.length > 0)\n  {\n    var xriUrl = match[1];\n    _resolveXri(xriUrl, callback);\n  }\n  else\n  {\n    callback(null);\n  }\n}\n\nvar _resolveXri = function(xriUrl, callback, hops)\n{\n  if(!hops)\n  {\n    hops = 1;\n  }\n  else if(hops >= 5)\n  {\n    return callback(null);\n  }\n\n  _get(xriUrl, null, function(data, headers, statusCode)\n  {\n    if(statusCode != 200)\n    {\n      return callback(null);\n    }\n\n    var xrdsLocation = headers['x-xrds-location'];\n    if(_isDef(xrdsLocation))\n    {\n      _get(xrdsLocation, null, function(data, headers, statusCode)\n      {\n        if(statusCode != 200 || data == null)\n        {\n          callback(null);\n        }\n        else\n        {\n          callback(_parseXrds(xrdsLocation, data));\n        }\n      });\n    }\n    else if(data != null)\n    {\n      var contentType = headers['content-type'];\n      // text/xml is not compliant, but some hosting providers refuse header\n      // changes, so text/xml is encountered\n      if(contentType && (contentType.indexOf('application/xrds+xml') === 0 || contentType.indexOf('text/xml') === 0))\n      {\n        return callback(_parseXrds(xriUrl, data));\n      }\n      else\n      {\n        return _resolveHtml(xriUrl, callback, hops + 1, data);\n      }\n    }\n  });\n}\n\nvar _resolveHtml = function(identifier, callback, hops, data)\n{\n  if(!hops)\n  {\n    hops = 1;\n  }\n  else if(hops >= 5)\n  {\n    return callback(null);\n  }\n\n  if(data == null)\n  {\n    _get(identifier, null, function(data, headers, statusCode)\n    {\n      if(statusCode != 200 || data == null)\n      {\n        callback(null);\n      }\n      else\n      {\n        _parseHtml(identifier, data, callback, hops + 1);\n      }\n    });\n  }\n  else\n  {\n    _parseHtml(identifier, data, callback, hops);\n  }\n\n}\n\nvar _resolveHostMeta = function(identifier, strict, callback, fallBackToProxy)\n{\n  var host = url.parse(identifier);\n  var hostMetaUrl;\n  if(fallBackToProxy && !strict)\n  {\n    hostMetaUrl = 'https://www.google.com/accounts/o8/.well-known/host-meta?hd=' + host.host;\n  }\n  else\n  {\n    hostMetaUrl = host.protocol + '//' + host.host + '/.well-known/host-meta';\n  }\n  if(!hostMetaUrl)\n  {\n    callback(null);\n  }\n  else\n  {\n    _get(hostMetaUrl, null, function(data, headers, statusCode)\n    {\n      if(statusCode != 200 || data == null)\n      {\n        if(!fallBackToProxy && !strict){\n          _resolveHostMeta(identifier, strict, callback, true);\n        }\n        else{\n          callback(null);\n        }\n      }\n      else\n      {\n        //Attempt to parse the data but if this fails it may be because\n        //the response to hostMetaUrl was some other http/html resource.\n        //Therefore fallback to the proxy if no providers are found.\n        _parseHostMeta(data, function(providers){\n          if((providers == null || providers.length == 0) && !fallBackToProxy && !strict) {\n            _resolveHostMeta(identifier, strict, callback, true);\n          }\n          else{\n            callback(providers);\n          }\n        });\n      }\n    });\n  }\n}\n\nopenid.discover = function(identifier, strict, callback)\n{\n  identifier = _normalizeIdentifier(identifier);\n  if(!identifier) \n  {\n    return callback({ message: 'Invalid identifier' }, null);\n  }\n  if(identifier.indexOf('http') !== 0)\n  {\n    // XRDS\n    identifier = 'https://xri.net/' + identifier + '?_xrd_r=application/xrds%2Bxml';\n  }\n\n  // Try XRDS/Yadis discovery\n  _resolveXri(identifier, function(providers)\n  {\n    if(providers == null || providers.length == 0)\n    {\n      // Fallback to HTML discovery\n      _resolveHtml(identifier, function(providers)\n      {\n        if(providers == null || providers.length == 0){\n          _resolveHostMeta(identifier, strict, function(providers){\n            callback(null, providers);\n          });\n        }\n        else{\n          callback(null, providers);\n        }\n      });\n    }\n    else\n    {\n      // Add claimed identifier to providers with local identifiers\n      // and OpenID 1.0/1.1 providers to ensure correct resolution \n      // of identities and services\n      for(var i = 0, len = providers.length; i < len; ++i)\n      {\n        var provider = providers[i];\n        if(!provider.claimedIdentifier && \n          (provider.localIdentifier || provider.version.indexOf('2.0') === -1))\n        {\n          provider.claimedIdentifier = identifier;\n        }\n      }\n      callback(null, providers);\n    }\n  });\n}\n\nvar _createDiffieHellmanKeyExchange = function(algorithm)\n{\n  var defaultPrime = 'ANz5OguIOXLsDhmYmsWizjEOHTdxfo2Vcbt2I3MYZuYe91ouJ4mLBX+YkcLiemOcPym2CBRYHNOyyjmG0mg3BVd9RcLn5S3IHHoXGHblzqdLFEi/368Ygo79JRnxTkXjgmY0rxlJ5bU1zIKaSDuKdiI+XUkKJX8Fvf8W8vsixYOr';\n\n  var dh = crypto.createDiffieHellman(defaultPrime, 'base64');\n\n  dh.generateKeys();\n\n  return dh;\n}\n\nopenid.associate = function(provider, callback, strict, algorithm)\n{\n  var params = _generateAssociationRequestParameters(provider.version, algorithm);\n  if(!_isDef(algorithm))\n  {\n    algorithm = 'DH-SHA256';\n  }\n\n  var dh = null;\n  if(algorithm.indexOf('no-encryption') === -1)\n  {\n    dh = _createDiffieHellmanKeyExchange(algorithm);\n    params['openid.dh_modulus'] = _bigIntToBase64(dh.getPrime('binary'));\n    params['openid.dh_gen'] = _bigIntToBase64(dh.getGenerator('binary'));\n    params['openid.dh_consumer_public'] = _bigIntToBase64(dh.getPublicKey('binary'));\n  }\n\n  _post(provider.endpoint, params, function(data, headers, statusCode)\n  {\n    if ((statusCode != 200 && statusCode != 400) || data === null)\n    {\n      return callback({ \n        message: 'HTTP request failed' \n      }, { \n        error: 'HTTP request failed', \n        error_code: ''  + statusCode, \n        ns: 'http://specs.openid.net/auth/2.0' \n      });\n    }\n    \n    data = _decodePostData(data);\n\n    if(data.error_code == 'unsupported-type' || !_isDef(data.ns))\n    {\n      if(algorithm == 'DH-SHA1')\n      {\n        if(strict && provider.endpoint.toLowerCase().indexOf('https:') !== 0)\n        {\n          return callback({ message: 'Channel is insecure and no encryption method is supported by provider' }, null);\n        }\n        else\n        {\n          return openid.associate(provider, callback, strict, 'no-encryption-256');\n        }\n      }\n      else if(algorithm == 'no-encryption-256')\n      {\n        if(strict && provider.endpoint.toLowerCase().indexOf('https:') !== 0)\n        {\n          return callback('Channel is insecure and no encryption method is supported by provider', null);\n        }\n        /*else if(provider.version.indexOf('2.0') === -1)\n        {\n          // 2011-07-22: This is an OpenID 1.0/1.1 provider which means\n          // HMAC-SHA1 has already been attempted with a blank session\n          // type as per the OpenID 1.0/1.1 specification.\n          // (See http://openid.net/specs/openid-authentication-1_1.html#mode_associate)\n          // However, providers like wordpress.com don't follow the \n          // standard and reject these requests, but accept OpenID 2.0\n          // style requests without a session type, so we have to give\n          // those a shot as well.\n          callback({ message: 'Provider is OpenID 1.0/1.1 and does not support OpenID 1.0/1.1 association.' });\n        }*/\n        else\n        {\n          return openid.associate(provider, callback, strict, 'no-encryption');\n        }\n      }\n      else if(algorithm == 'DH-SHA256')\n      {\n        return openid.associate(provider, callback, strict, 'DH-SHA1');\n      }\n    }\n\n    if (data.error)\n    {\n      callback({ message: data.error }, data);\n    }\n    else\n    {\n      var secret = null;\n\n      var hashAlgorithm = algorithm.indexOf('256') !== -1 ? 'sha256' : 'sha1';\n\n      if(algorithm.indexOf('no-encryption') !== -1)\n      {\n        secret = data.mac_key;\n      }\n      else\n      {\n        var serverPublic = _bigIntFromBase64(data.dh_server_public);\n        var sharedSecret = _btwoc(dh.computeSecret(serverPublic, 'binary', 'binary'));\n        var hash = crypto.createHash(hashAlgorithm);\n        hash.update(_buffer(sharedSecret, 'binary'));\n        sharedSecret = hash.digest('binary');\n        var encMacKey = _base64decode(data.enc_mac_key);\n        secret = _base64encode(_xor(encMacKey, sharedSecret));\n      }\n\n      if (!_isDef(data.assoc_handle)) {\n        return callback({ message: 'OpenID provider does not seem to support association; you need to use stateless mode'}, null);\n      }\n\n      openid.saveAssociation(provider, hashAlgorithm,\n        data.assoc_handle, secret, data.expires_in * 1, function(error)\n        {\n          if(error)\n          {\n            return callback(error);\n          }\n          callback(null, data);\n        });\n    }\n  });\n}\n\nvar _generateAssociationRequestParameters = function(version, algorithm)\n{\n  var params = {\n    'openid.mode' : 'associate',\n  };\n\n  if(version.indexOf('2.0') !== -1)\n  {\n    params['openid.ns'] = 'http://specs.openid.net/auth/2.0';\n  }\n\n  if(algorithm == 'DH-SHA1')\n  {\n    params['openid.assoc_type'] = 'HMAC-SHA1';\n    params['openid.session_type'] = 'DH-SHA1';\n  }\n  else if(algorithm == 'no-encryption-256')\n  {\n    if(version.indexOf('2.0') === -1)\n    {\n      params['openid.session_type'] = ''; // OpenID 1.0/1.1 requires blank\n      params['openid.assoc_type'] = 'HMAC-SHA1';\n    }\n    else\n    {\n      params['openid.session_type'] = 'no-encryption';\n      params['openid.assoc_type'] = 'HMAC-SHA256';\n    }\n  }\n  else if(algorithm == 'no-encryption')\n  {\n    if(version.indexOf('2.0') !== -1)\n    {\n      params['openid.session_type'] = 'no-encryption';\n    }\n    params['openid.assoc_type'] = 'HMAC-SHA1';\n  }\n  else\n  {\n    params['openid.assoc_type'] = 'HMAC-SHA256';\n    params['openid.session_type'] = 'DH-SHA256';\n  }\n\n  return params;\n}\n\nopenid.authenticate = function(identifier, returnUrl, realm, immediate, stateless, callback, extensions, strict)\n{\n  openid.discover(identifier, strict, function(error, providers)\n  {\n    if(error)\n    {\n      return callback(error);\n    }\n    if(!providers || providers.length === 0)\n    {\n      return callback({ message: 'No providers found for the given identifier' }, null);\n    }\n\n    var providerIndex = -1;\n\n    (function chooseProvider(error, authUrl)\n    {\n      if(!error && authUrl)\n      {\n        var provider = providers[providerIndex];\n\n        if(provider.claimedIdentifier)\n        {\n          var useLocalIdentifierAsKey = provider.version.indexOf('2.0') === -1 && provider.localIdentifier && provider.claimedIdentifier != provider.localIdentifier;\n\n          return openid.saveDiscoveredInformation(useLocalIdentifierAsKey ? provider.localIdentifier : provider.claimedIdentifier, \n            provider, function(error)\n          {\n            if(error)\n            {\n              return callback(error);\n            }\n            return callback(null, authUrl);\n          });\n        }\n        else if(provider.version.indexOf('2.0') !== -1)\n        {\n          return callback(null, authUrl);\n        }\n        else\n        {\n          chooseProvider({ message: 'OpenID 1.0/1.1 provider cannot be used without a claimed identifier' });\n        }\n      }\n      if(++providerIndex >= providers.length)\n      {\n        return callback({ message: 'No usable providers found for the given identifier' }, null);\n      }\n\n      var currentProvider = providers[providerIndex];\n      if(stateless)\n      {\n        _requestAuthentication(currentProvider, null, returnUrl, \n          realm, immediate, extensions || {}, chooseProvider);\n      }\n\n      else\n      {\n        openid.associate(currentProvider, function(error, answer)\n        {\n          if(error || !answer || answer.error)\n          {\n            chooseProvider(error || answer.error, null);\n          }\n          else\n          {\n            _requestAuthentication(currentProvider, answer.assoc_handle, returnUrl, \n              realm, immediate, extensions || {}, chooseProvider);\n          }\n        });\n        \n      }\n    })();\n  });\n}\n\nvar _requestAuthentication = function(provider, assoc_handle, returnUrl, realm, immediate, extensions, callback)\n{\n  var params = {\n    'openid.mode' : immediate ? 'checkid_immediate' : 'checkid_setup'\n  };\n\n  if(provider.version.indexOf('2.0') !== -1)\n  {\n    params['openid.ns'] = 'http://specs.openid.net/auth/2.0';\n  }\n\n  for (var i in extensions)\n  {\n    if(!hasOwnProperty(extensions, i))\n    {\n      continue;\n    }\n\n    var extension = extensions[i];\n    for (var key in extension.requestParams)\n    {\n      if (!hasOwnProperty(extension.requestParams, key)) { continue; }\n      params[key] = extension.requestParams[key];\n    }\n  }\n\n  if(provider.claimedIdentifier)\n  {\n    params['openid.claimed_id'] = provider.claimedIdentifier;\n    if(provider.localIdentifier)\n    {\n      params['openid.identity'] = provider.localIdentifier;\n    }\n    else\n    {\n      params['openid.identity'] = provider.claimedIdentifier;\n    }\n  }\n  else if(provider.version.indexOf('2.0') !== -1)\n  {\n    params['openid.claimed_id'] = params['openid.identity'] =\n      'http://specs.openid.net/auth/2.0/identifier_select';\n  }\n  else {\n    return callback({ message: 'OpenID 1.0/1.1 provider cannot be used without a claimed identifier' });\n  }\n\n  if(assoc_handle)\n  {\n    params['openid.assoc_handle'] = assoc_handle;\n  }\n\n  if(returnUrl)\n  {\n    // Value should be missing if RP does not want\n    // user to be sent back\n    params['openid.return_to'] = returnUrl;\n  }\n\n  if(realm)\n  {\n    if(provider.version.indexOf('2.0') !== -1) {\n      params['openid.realm'] = realm;\n    }\n    else {\n      params['openid.trust_root'] = realm;\n    }\n  }\n  else if(!returnUrl)\n  {\n    return callback({ message: 'No return URL or realm specified' });\n  }\n\n  callback(null, _buildUrl(provider.endpoint, params));\n}\n\nopenid.verifyAssertion = function(requestOrUrl, originalReturnUrl, callback, stateless, extensions, strict)\n{\n  extensions = extensions || {};\n  var assertionUrl = requestOrUrl;\n  if(typeof(requestOrUrl) !== typeof(''))\n  {\n    if(requestOrUrl.method.toUpperCase() == 'POST') {\n      if((requestOrUrl.headers['content-type'] || '').toLowerCase().indexOf('application/x-www-form-urlencoded') === 0) {\n        // POST response received\n        var data = '';\n        \n        requestOrUrl.on('data', function(chunk) {\n          data += chunk;\n        });\n        \n        requestOrUrl.on('end', function() {\n          var params = querystring.parse(data);\n          return _verifyAssertionData(params, callback, stateless, extensions, strict);\n        });\n      }\n      else {\n        return callback({ message: 'Invalid POST response from OpenID provider' });\n      }\n      \n      return; // Avoid falling through to GET method assertion\n    }\n    else if(requestOrUrl.method.toUpperCase() != 'GET') {\n      return callback({ message: 'Invalid request method from OpenID provider' });\n    }\n    assertionUrl = requestOrUrl.url;\n  }\n\n  assertionUrl = url.parse(assertionUrl, true);\n  var params = assertionUrl.query;\n\n  if (!_verifyReturnUrl(assertionUrl, originalReturnUrl)) {\n      return callback({ message: 'Invalid return URL' });\n  }\n  return _verifyAssertionData(params, callback, stateless, extensions, strict);\n}\n\nvar _verifyReturnUrl = function (assertionUrl, originalReturnUrl) {\n  var receivedReturnUrl = assertionUrl.query['openid.return_to'];\n  if (!_isDef(receivedReturnUrl)) {\n    return false;\n  }\n\n  receivedReturnUrl = url.parse(receivedReturnUrl, true);\n  if (!receivedReturnUrl) {\n    return false;\n  }\n  originalReturnUrl = url.parse(originalReturnUrl, true);\n  if (!originalReturnUrl) {\n    return false;\n  }\n\n  if (originalReturnUrl.protocol !== receivedReturnUrl.protocol || // Verify scheme against original return URL\n      originalReturnUrl.host !== receivedReturnUrl.host || // Verify authority against original return URL\n      originalReturnUrl.pathname !== receivedReturnUrl.pathname) { // Verify path against current request URL\n    return false;\n  }\n\n  // Any query parameters that are present in the \"openid.return_to\" URL MUST also be present \n  // with the same values in the URL of the HTTP request the RP received\n  for (var param in receivedReturnUrl.query) {\n    if (hasOwnProperty(receivedReturnUrl.query, param) && receivedReturnUrl.query[param] !== assertionUrl.query[param]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _verifyAssertionData = function(params, callback, stateless, extensions, strict) {\n  var assertionError = _getAssertionError(params);\n  if(assertionError)\n  {\n    return callback({ message: assertionError }, { authenticated: false });\n  }\n\n  if (!_invalidateAssociationHandleIfRequested(params)) {\n    return callback({ message: 'Unable to invalidate association handle'});\n  }\n\n  if (!_checkNonce(params)) {\n      return callback({ message: 'Invalid or replayed nonce' });\n  }\n\n  _verifyDiscoveredInformation(params, stateless, extensions, strict, function(error, result)\n  {\n    return callback(error, result);\n  });\n};\n\nvar _getAssertionError = function(params)\n{\n  if(!_isDef(params))\n  {\n    return 'Assertion request is malformed';\n  }\n  else if(params['openid.mode'] == 'error')\n  {\n    return params['openid.error'];\n  }\n  else if(params['openid.mode'] == 'cancel')\n  {\n    return 'Authentication cancelled';\n  }\n\n  return null;\n}\n\nvar _invalidateAssociationHandleIfRequested = function(params)\n{\n  if (params['is_valid'] == 'true' && _isDef(params['openid.invalidate_handle'])) {\n    if(!openid.removeAssociation(params['openid.invalidate_handle'])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _checkNonce = function (params) {\n  if (!_isDef(params['openid.ns'])) {\n    return true; // OpenID 1.1 has no nonce\n  }\n  if (!_isDef(params['openid.response_nonce'])) {\n    return false;\n  }\n\n  var nonce = params['openid.response_nonce'];\n  var timestampEnd = nonce.indexOf('Z');\n  if (timestampEnd == -1) {\n    return false;\n  }\n\n  // Check for valid timestamp in nonce\n  var timestamp = new Date(Date.parse(nonce.substring(0, timestampEnd + 1)));\n  if (Object.prototype.toString.call(timestamp) !== '[object Date]' || isNaN(timestamp)) {\n    return false;\n  }\n    \n  // Remove old nonces from our store (nonces that are more skewed than 5 minutes)\n  _removeOldNonces();\n\n  // Check if nonce is skewed by more than 5 minutes\n  if (Math.abs(new Date().getTime() - timestamp.getTime()) > 300000) {\n    return false;\n  }\n\n  // Check if nonce is replayed\n  if (_isDef(_nonces[nonce])) {\n    return false;\n  }\n\n  // Store the nonce\n  _nonces[nonce] = timestamp;\n  return true;\n}\n\nvar _removeOldNonces = function () {\n  for (var nonce in _nonces) {\n    if (hasOwnProperty(_nonces, nonce) && Math.abs(new Date().getTime() - _nonces[nonce].getTime()) > 300000) {\n      delete _nonces[nonce];\n    }\n  }\n}\n\nvar _verifyDiscoveredInformation = function(params, stateless, extensions, strict, callback)\n{\n  var claimedIdentifier = params['openid.claimed_id'];\n  var useLocalIdentifierAsKey = false;\n  if(!_isDef(claimedIdentifier))\n  {\n    if(!_isDef(params['openid.ns']))\n    {\n      // OpenID 1.0/1.1 response without a claimed identifier\n      // We need to load discovered information using the\n      // local identifier\n      useLocalIdentifierAsKey = true;\n    }\n    else {\n      // OpenID 2.0+:\n      // If there is no claimed identifier, then the\n      // assertion is not about an identity\n      return callback(null, { authenticated: false }); \n      }\n  }\n\n  if (useLocalIdentifierAsKey) {\n    claimedIdentifier = params['openid.identity'];  \n  }\n\n  claimedIdentifier = _getCanonicalClaimedIdentifier(claimedIdentifier);\n  openid.loadDiscoveredInformation(claimedIdentifier, function(error, provider)\n  {\n    if(error)\n    {\n      return callback({ message: 'An error occured when loading previously discovered information about the claimed identifier' });\n    }\n\n    if(provider)\n    {\n      return _verifyAssertionAgainstProviders([provider], params, stateless, extensions, callback);\n    }\n    else if (useLocalIdentifierAsKey) {\n      return callback({ message: 'OpenID 1.0/1.1 response received, but no information has been discovered about the provider. It is likely that this is a fraudulent authentication response.' });\n    }\n    \n    openid.discover(claimedIdentifier, strict, function(error, providers)\n    {\n      if(error)\n      {\n        return callback(error);\n      }\n      if(!providers || !providers.length)\n      {\n        return callback({ message: 'No OpenID provider was discovered for the asserted claimed identifier' });\n      }\n\n      _verifyAssertionAgainstProviders(providers, params, stateless, extensions, callback);\n    });\n  });\n}\n\nvar _verifyAssertionAgainstProviders = function(providers, params, stateless, extensions, callback)\n{\n  for(var i = 0; i < providers.length; ++i)\n  {\n    var provider = providers[i];\n    if(!!params['openid.ns'] && (!provider.version || provider.version.indexOf(params['openid.ns']) !== 0))\n    {\n      continue;\n    }\n\n    if(!!provider.version && provider.version.indexOf('2.0') !== -1)\n    {\n      var endpoint = params['openid.op_endpoint'];\n      if (provider.endpoint != endpoint) \n      {\n        continue;\n      }\n      if(provider.claimedIdentifier) {\n        var claimedIdentifier = _getCanonicalClaimedIdentifier(params['openid.claimed_id']);\n        if(provider.claimedIdentifier != claimedIdentifier) {\n          return callback({ message: 'Claimed identifier in assertion response does not match discovered claimed identifier' });\n        }\n      }\n    }\n\n    if(!!provider.localIdentifier && provider.localIdentifier != params['openid.identity'])\n    {\n      return callback({ message: 'Identity in assertion response does not match discovered local identifier' });\n    }\n\n    return _checkSignature(params, provider, stateless, function(error, result)\n    {\n      if(error)\n      {\n        return callback(error);\n      }\n      if(extensions && result.authenticated)\n      {\n        for(var ext in extensions)\n        {\n          if (!hasOwnProperty(extensions, ext))\n          { \n            continue; \n          }\n          var instance = extensions[ext];\n          instance.fillResult(params, result);\n        }\n      }\n\n      return callback(null, result);\n    });\n  }\n\n  callback({ message: 'No valid providers were discovered for the asserted claimed identifier' });\n}\n\nvar _checkSignature = function(params, provider, stateless, callback)\n{\n  if(!_isDef(params['openid.signed']) ||\n    !_isDef(params['openid.sig']))\n  {\n    return callback({ message: 'No signature in response' }, { authenticated: false });\n  }\n\n  if(stateless)\n  {\n    _checkSignatureUsingProvider(params, provider, callback);\n  }\n  else\n  {\n    _checkSignatureUsingAssociation(params, callback);\n  }\n}\n\nvar _checkSignatureUsingAssociation = function(params, callback)\n{\n  if (!_isDef(params['openid.assoc_handle']))\n  {\n    return callback({ message: 'No association handle in provider response. Find out whether the provider supports associations and/or use stateless mode.' });\n  }\n  openid.loadAssociation(params['openid.assoc_handle'], function(error, association)\n  {\n    if(error)\n    {\n      return callback({ message: 'Error loading association' }, { authenticated: false });\n    }\n    if(!association)\n    {\n      return callback({ message:'Invalid association handle' }, { authenticated: false });\n    }\n    if(association.provider.version.indexOf('2.0') !== -1 && association.provider.endpoint !== params['openid.op_endpoint'])\n    {\n      return callback({ message:'Association handle does not match provided endpoint' }, {authenticated: false});\n    }\n    \n    var message = '';\n    var signedParams = params['openid.signed'].split(',');\n    for(var i = 0; i < signedParams.length; i++)\n    {\n      var param = signedParams[i];\n      var value = params['openid.' + param];\n      if(!_isDef(value))\n      {\n        return callback({ message: 'At least one parameter referred in signature is not present in response' }, { authenticated: false });\n      }\n      message += param + ':' + value + '\\n';\n    }\n\n    var hmac = crypto.createHmac(association.type, _buffer(association.secret, 'base64'));\n    hmac.update(message, 'utf8');\n    var ourSignature = hmac.digest('base64');\n\n    if(ourSignature == params['openid.sig'])\n    {\n      callback(null, { authenticated: true, claimedIdentifier: association.provider.version.indexOf('2.0') !== -1 ? params['openid.claimed_id'] : association.provider.claimedIdentifier });\n    }\n    else\n    {\n      callback({ message: 'Invalid signature' }, { authenticated: false });\n    }\n  });\n}\n\nvar _checkSignatureUsingProvider = function(params, provider, callback)\n{\n  var requestParams = \n  {\n    'openid.mode' : 'check_authentication'\n  };\n  for(var key in params)\n  {\n    if(hasOwnProperty(params, key) && key != 'openid.mode')\n    {\n      requestParams[key] = params[key];\n    }\n  }\n\n  _post(_isDef(params['openid.ns']) ? (params['openid.op_endpoint'] || provider.endpoint) : provider.endpoint, requestParams, function(data, headers, statusCode)\n  {\n    if(statusCode != 200 || data == null)\n    {\n      return callback({ message: 'Invalid assertion response from provider' }, { authenticated: false });\n    }\n    else\n    {\n      data = _decodePostData(data);\n      if(data['is_valid'] == 'true')\n      {\n        return callback(null, { authenticated: true, claimedIdentifier: provider.version.indexOf('2.0') !== -1 ? params['openid.claimed_id'] : params['openid.identity'] });\n      }\n      else\n      {\n        return callback({ message: 'Invalid signature' }, { authenticated: false });\n      }\n    }\n  });\n\n}\n\n\nvar _getCanonicalClaimedIdentifier = function(claimedIdentifier) {\n  if(!claimedIdentifier) {\n    return claimedIdentifier;\n  }\n\n  var index = claimedIdentifier.indexOf('#');\n  if (index !== -1) {\n    return claimedIdentifier.substring(0, index);\n  }\n\n  return claimedIdentifier;\n};\n\n/* ==================================================================\n * Extensions\n * ================================================================== \n */\n\nvar _getExtensionAlias = function(params, ns) \n{\n  for (var k in params)\n    if (params[k] == ns)\n      return k.replace(\"openid.ns.\", \"\");\n}\n\n/* \n * Simple Registration Extension\n * http://openid.net/specs/openid-simple-registration-extension-1_1-01.html\n */\n\nvar sreg_keys = ['nickname', 'email', 'fullname', 'dob', 'gender', 'postcode', 'country', 'language', 'timezone'];\n\nopenid.SimpleRegistration = function SimpleRegistration(options) \n{\n  this.requestParams = {'openid.ns.sreg': 'http://openid.net/extensions/sreg/1.1'};\n  if (options.policy_url)\n    this.requestParams['openid.sreg.policy_url'] = options.policy_url;\n  var required = [];\n  var optional = [];\n  for (var i = 0; i < sreg_keys.length; i++)\n  {\n    var key = sreg_keys[i];\n    if (options[key]) \n    {\n      if (options[key] == 'required')\n      {\n        required.push(key);\n      }\n      else\n      {\n        optional.push(key);\n      }\n    }\n    if (required.length)\n    {\n      this.requestParams['openid.sreg.required'] = required.join(',');\n    }\n    if (optional.length)\n    {\n      this.requestParams['openid.sreg.optional'] = optional.join(',');\n    }\n  }\n};\n\nopenid.SimpleRegistration.prototype.fillResult = function(params, result)\n{\n  var extension = _getExtensionAlias(params, 'http://openid.net/extensions/sreg/1.1') || 'sreg';\n  for (var i = 0; i < sreg_keys.length; i++)\n  {\n    var key = sreg_keys[i];\n    if (params['openid.' + extension + '.' + key])\n    {\n      result[key] = params['openid.' + extension + '.' + key];\n    }\n  }\n};\n\n/* \n * User Interface Extension\n * http://svn.openid.net/repos/specifications/user_interface/1.0/trunk/openid-user-interface-extension-1_0.html \n */\nopenid.UserInterface = function UserInterface(options) \n{\n  if (typeof(options) != 'object')\n  {\n    options = { mode: options || 'popup' };\n  }\n\n  this.requestParams = {'openid.ns.ui': 'http://specs.openid.net/extensions/ui/1.0'};\n  for (var k in options) \n  {\n    this.requestParams['openid.ui.' + k] = options[k];\n  }\n};\n\nopenid.UserInterface.prototype.fillResult = function(params, result)\n{\n  // TODO: Fill results\n}\n\n/* \n * Attribute Exchange Extension\n * http://openid.net/specs/openid-attribute-exchange-1_0.html \n * Also see:\n *  - http://www.axschema.org/types/ \n *  - http://code.google.com/intl/en-US/apis/accounts/docs/OpenID.html#Parameters\n */\n\nvar attributeMapping = \n{\n    'http://axschema.org/contact/country/home': 'country'\n  , 'http://axschema.org/contact/email': 'email'\n  , 'http://axschema.org/namePerson/first': 'firstname'\n  , 'http://axschema.org/pref/language': 'language'\n  , 'http://axschema.org/namePerson/last': 'lastname'\n  // The following are not in the Google document:\n  , 'http://axschema.org/namePerson/friendly': 'nickname'\n  , 'http://axschema.org/namePerson': 'fullname'\n};\n\nopenid.AttributeExchange = function AttributeExchange(options) \n{ \n  this.requestParams = {'openid.ns.ax': 'http://openid.net/srv/ax/1.0',\n    'openid.ax.mode' : 'fetch_request'};\n  var required = [];\n  var optional = [];\n  for (var ns in options)\n  {\n    if (!hasOwnProperty(options, ns)) { continue; }\n    if (options[ns] == 'required')\n    {\n      required.push(ns);\n    }\n    else\n    {\n      optional.push(ns);\n    }\n  }\n  var self = this;\n  required = required.map(function(ns, i) \n  {\n    var attr = attributeMapping[ns] || 'req' + i;\n    self.requestParams['openid.ax.type.' + attr] = ns;\n    return attr;\n  });\n  optional = optional.map(function(ns, i)\n  {\n    var attr = attributeMapping[ns] || 'opt' + i;\n    self.requestParams['openid.ax.type.' + attr] = ns;\n    return attr;\n  });\n  if (required.length)\n  {\n    this.requestParams['openid.ax.required'] = required.join(',');\n  }\n  if (optional.length)\n  {\n    this.requestParams['openid.ax.if_available'] = optional.join(',');\n  }\n}\n\nopenid.AttributeExchange.prototype.fillResult = function(params, result)\n{\n  var extension = _getExtensionAlias(params, 'http://openid.net/srv/ax/1.0') || 'ax';\n  var regex = new RegExp('^openid\\\\.' + extension + '\\\\.(value|type|count)\\\\.(\\\\w+)(\\\\.(\\\\d+)){0,1}$');\n  var aliases = {};\n  var counters = {};\n  var values = {};\n  for (var k in params)\n  {\n    if (!hasOwnProperty(params, k)) { continue; }\n    var matches = k.match(regex);\n    if (!matches)\n    {\n      continue;\n    }\n    if (matches[1] == 'type')\n    {\n      aliases[params[k]] = matches[2];\n    }\n    else if (matches[1] == 'count')\n    {\n      //counter sanitization\n      var count = parseInt(params[k], 10);\n\n      // values number limitation (potential attack by overflow ?)\n      counters[matches[2]] = (count < AX_MAX_VALUES_COUNT) ? count : AX_MAX_VALUES_COUNT ;\n    }\n    else\n    {\n      if (matches[3])\n      {\n        //matches multi-value, aka \"count\" aliases\n\n        //counter sanitization\n        var count = parseInt(matches[4], 10);\n\n        // \"in bounds\" verification\n        if (count > 0 && count <= (counters[matches[2]] || AX_MAX_VALUES_COUNT))\n        {\n          if (!values[matches[2]]) {\n            values[matches[2]] = [];\n          }\n          values[matches[2]][count-1] = params[k];\n        }\n      }\n      else\n      {\n        //matches single-value aliases\n        values[matches[2]] = params[k];\n      }\n    }\n  }\n  for (var ns in aliases) \n  {\n    if (aliases[ns] in values)\n    {\n      result[aliases[ns]] = values[aliases[ns]];\n      result[ns] = values[aliases[ns]];\n    }\n  }\n}\n\nopenid.OAuthHybrid = function(options)\n{\n  this.requestParams = {\n    'openid.ns.oauth'       : 'http://specs.openid.net/extensions/oauth/1.0',\n    'openid.oauth.consumer' : options['consumerKey'],\n    'openid.oauth.scope'    : options['scope']};\n}\n\nopenid.OAuthHybrid.prototype.fillResult = function(params, result)\n{\n  var extension = _getExtensionAlias(params, 'http://specs.openid.net/extensions/oauth/1.0') || 'oauth'\n    , token_attr = 'openid.' + extension + '.request_token';\n  \n  \n  if(params[token_attr] !== undefined)\n  {\n    result['request_token'] = params[token_attr];\n  }\n};\n\n/* \n * Provider Authentication Policy Extension (PAPE)\n * http://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html\n * \n * Note that this extension does not validate that the provider is obeying the\n * authentication request, it only allows the request to be made.\n *\n * TODO: verify requested 'max_auth_age' against response 'auth_time'\n * TODO: verify requested 'auth_level.ns.<cust>' (etc) against response 'auth_level.ns.<cust>'\n * TODO: verify requested 'preferred_auth_policies' against response 'auth_policies'\n *\n */\n\n/* Just the keys that aren't open to customisation */\nvar pape_request_keys = ['max_auth_age', 'preferred_auth_policies', 'preferred_auth_level_types' ];\nvar pape_response_keys = ['auth_policies', 'auth_time']\n\n/* Some short-hand mappings for auth_policies */ \nvar papePolicyNameMap = \n{\n    'phishing-resistant': 'http://schemas.openid.net/pape/policies/2007/06/phishing-resistant',\n    'multi-factor': 'http://schemas.openid.net/pape/policies/2007/06/multi-factor',\n    'multi-factor-physical': 'http://schemas.openid.net/pape/policies/2007/06/multi-factor-physical',\n    'none' : 'http://schemas.openid.net/pape/policies/2007/06/none'\n}\n \nopenid.PAPE = function PAPE(options) \n{\n  this.requestParams = {'openid.ns.pape': 'http://specs.openid.net/extensions/pape/1.0'};\n  for (var k in options) \n  {\n    if (k === 'preferred_auth_policies') {\n      this.requestParams['openid.pape.' + k] = _getLongPolicyName(options[k]);\n    } else {\n      this.requestParams['openid.pape.' + k] = options[k];\n    }\n  }\n  var util = require('util');\n};\n\n/* you can express multiple pape 'preferred_auth_policies', so replace each\n * with the full policy URI as per papePolicyNameMapping. \n */\nvar _getLongPolicyName = function(policyNames) {\n  var policies = policyNames.split(' ');   \n  for (var i=0; i<policies.length; i++) {\n    if (policies[i] in papePolicyNameMap) {\n      policies[i] = papePolicyNameMap[policies[i]];\n    }\n  }\n  return policies.join(' ');\n}\n\nvar _getShortPolicyName = function(policyNames) {\n  var policies = policyNames.split(' ');   \n  for (var i=0; i<policies.length; i++) {\n    for (shortName in papePolicyNameMap) {\n      if (papePolicyNameMap[shortName] === policies[i]) {\n        policies[i] = shortName;\n      }\n    }\n  }\n  return policies.join(' ');\n}\n\nopenid.PAPE.prototype.fillResult = function(params, result)\n{\n  var extension = _getExtensionAlias(params, 'http://specs.openid.net/extensions/pape/1.0') || 'pape';\n  var paramString = 'openid.' + extension + '.';\n  var thisParam;\n  for (var p in params) {\n    if (hasOwnProperty(params, p)) {\n      if (p.substr(0, paramString.length) === paramString) {\n        thisParam = p.substr(paramString.length);\n        if (thisParam === 'auth_policies') {\n          result[thisParam] = _getShortPolicyName(params[p]);\n        } else {\n          result[thisParam] = params[p];\n        }\n      }\n    }\n  } \n}\n","/home/travis/build/npmtest/node-npmtest-openid/node_modules/openid/lib/xrds.js":"/* A simple XRDS and Yadis parser written for OpenID for node.js\r\n *\r\n * http://ox.no/software/node-openid\r\n * http://github.com/havard/node-openid\r\n *\r\n * Copyright (C) 2010 by Håvard Stranden\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  \r\n * -*- Mode: JS; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- \r\n * vim: set sw=2 ts=2 et tw=80 : \r\n */\r\n\r\nexports.parse  = function(data)\r\n{\r\n  data = data.replace(/\\r|\\n/g, '');\r\n  var services = [];\r\n  var serviceMatches = data.match(/<Service\\s*(priority=\"\\d+\")?.*?>(.*?)<\\/Service>/g);\r\n\r\n  if(!serviceMatches)\r\n  {\r\n    return services;\r\n  }\r\n\r\n  for(var s = 0, len = serviceMatches.length; s < len; ++s)\r\n  {\r\n    var service = serviceMatches[s];\r\n    var svcs = [];\r\n    var priorityMatch = /<Service.*?priority=\"(.*?)\".*?>/g.exec(service);\r\n    var priority = 0;\r\n    if(priorityMatch)\r\n    {\r\n      priority = parseInt(priorityMatch[1], 10);\r\n    }\r\n\r\n    var typeMatch = null;\r\n    var typeRegex = new RegExp('<Type(\\\\s+.*?)?>(.*?)<\\\\/Type\\\\s*?>', 'g');\r\n    while(typeMatch = typeRegex.exec(service))\r\n    {\r\n      svcs.push({ priority: priority, type: typeMatch[2] });\r\n    }\r\n\r\n    if(svcs.length == 0)\r\n    {\r\n      continue;\r\n    }\r\n\r\n    var idMatch = /<(Local|Canonical)ID\\s*?>(.*?)<\\/\\1ID\\s*?>/g.exec(service);\r\n    if(idMatch)\r\n    {\r\n      for(var i = 0; i < svcs.length; i++)\r\n      {\r\n        var svc = svcs[i];\r\n        svc.id = idMatch[2];\r\n      }\r\n    }\r\n    \r\n    var uriMatch = /<URI(\\s+.*?)?>(.*?)<\\/URI\\s*?>/g.exec(service);\r\n    if(!uriMatch)\r\n    {\r\n      continue;\r\n    }\r\n\r\n    for(var i = 0; i < svcs.length; i++)\r\n    {\r\n      var svc = svcs[i];\r\n      svc.uri = uriMatch[2];\r\n    }\r\n\r\n    var delegateMatch = /<(.*?Delegate)\\s*?>(.*)<\\/\\1\\s*?>/g.exec(service);\r\n    if(delegateMatch)\r\n    {\r\n      svc.delegate = delegateMatch[2];\r\n    }\r\n\r\n    services.push.apply(services, svcs);\r\n  }\r\n\r\n  services.sort(function(a, b) \r\n  { \r\n    return a.priority < b.priority \r\n      ? -1 \r\n      : (a.priority == b.priority ? 0 : 1);\r\n  });\r\n\r\n  return services;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-openid/node_modules/openid/sample.js":"/* A simple sample demonstrating OpenID for node.js\r\n *\r\n * http://ox.no/software/node-openid\r\n * http://github.com/havard/node-openid\r\n *\r\n * Copyright (C) 2010 by Håvard Stranden\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n */\r\n\r\nvar openid = require('./openid');\r\nvar url = require('url');\r\nvar querystring = require('querystring');\r\n\r\nvar extensions = [new openid.UserInterface(), \r\n                  new openid.SimpleRegistration(\r\n                      {\r\n                        \"nickname\" : true, \r\n                        \"email\" : true, \r\n                        \"fullname\" : true,\r\n                        \"dob\" : true, \r\n                        \"gender\" : true, \r\n                        \"postcode\" : true,\r\n                        \"country\" : true, \r\n                        \"language\" : true, \r\n                        \"timezone\" : true\r\n                      }),\r\n                  new openid.AttributeExchange(\r\n                      {\r\n                        \"http://axschema.org/contact/email\": \"required\",\r\n                        \"http://axschema.org/namePerson/friendly\": \"required\",\r\n                        \"http://axschema.org/namePerson\": \"required\"\r\n                      }),\r\n                  new openid.PAPE(\r\n                      {\r\n                        \"max_auth_age\": 24 * 60 * 60, // one day\r\n                        \"preferred_auth_policies\" : \"none\" //no auth method preferred.\r\n                      })];\r\n\r\nvar relyingParty = new openid.RelyingParty(\r\n    'http://localhost:8080/verify', // Verification URL (yours)\r\n    null, // Realm (optional, specifies realm for OpenID authentication)\r\n    true, // Use stateless verification\r\n    false, // Strict mode\r\n    extensions); // List of extensions to enable and include\r\n\r\n\r\nvar server = require('http').createServer(\r\n    function(req, res)\r\n    {\r\n        var parsedUrl = url.parse(req.url);\r\n        if(parsedUrl.pathname == '/authenticate')\r\n        { \r\n          // User supplied identifier\r\n          var query = querystring.parse(parsedUrl.query);\r\n          var identifier = query.openid_identifier;\r\n\r\n          // Resolve identifier, associate, and build authentication URL\r\n          relyingParty.authenticate(identifier, false, function(error, authUrl)\r\n          {\r\n            if(error)\r\n            {\r\n              res.writeHead(200, { 'Content-Type' : 'text/plain; charset=utf-8' });\r\n              res.end('Authentication failed: ' + error.message);\r\n            }\r\n            else if (!authUrl)\r\n            {\r\n              res.writeHead(200, { 'Content-Type' : 'text/plain; charset=utf-8' });\r\n              res.end('Authentication failed');\r\n            }\r\n            else\r\n            {\r\n              res.writeHead(302, { Location: authUrl });\r\n              res.end();\r\n            }\r\n          });\r\n        }\r\n        else if(parsedUrl.pathname == '/verify')\r\n        {\r\n          // Verify identity assertion\r\n          // NOTE: Passing just the URL is also possible\r\n          relyingParty.verifyAssertion(req, function(error, result)\r\n          {\r\n            res.writeHead(200, { 'Content-Type' : 'text/plain; charset=utf-8' });\r\n\r\n            if(error)\r\n            {\r\n              res.end('Authentication failed: ' + error.message);\r\n            }\r\n            else\r\n            {\r\n              // Result contains properties:\r\n              // - authenticated (true/false)\r\n              // - answers from any extensions (e.g. \r\n              //   \"http://axschema.org/contact/email\" if requested \r\n              //   and present at provider)\r\n              res.end((result.authenticated ? 'Success :)' : 'Failure :(') +\r\n                '\\n\\n' + JSON.stringify(result));\r\n            }\r\n          });\r\n        }\r\n        else\r\n        {\r\n            // Deliver an OpenID form on all other URLs\r\n            res.writeHead(200, { 'Content-Type' : 'text/html; charset=utf-8' });\r\n            res.end('<!DOCTYPE html><html><body>'\r\n                + '<form method=\"get\" action=\"/authenticate\">'\r\n                + '<p>Login using OpenID</p>'\r\n                + '<input name=\"openid_identifier\" />'\r\n                + '<input type=\"submit\" value=\"Login\" />'\r\n                + '</form></body></html>');\r\n        }\r\n    });\r\nserver.listen(8080);\r\n","/home/travis/build/npmtest/node-npmtest-openid/node_modules/openid/expressjs_sample/authentication_controller.js":"var openid = require('openid');\r\n\r\nvar relyingParty = new openid.RelyingParty(\r\n    'http://localhost:8888/login/verify', // Verification URL (yours)\r\n    null, // Realm (optional, specifies realm for OpenID authentication)\r\n    false, // Use stateless verification\r\n    false, // Strict mode\r\n    []); // List of extensions to enable and include\r\n\r\napp.get('/login', function(request, response) {\r\n\tresponse.render('login');\r\n});\r\n\r\napp.get('/login/authenticate', function(request, response) {\r\n\tvar identifier = request.query.openid_identifier;\r\n\r\n\t// Resolve identifier, associate, and build authentication URL\r\n\trelyingParty.authenticate(identifier, false, function(error, authUrl) \t{\r\n\t\tif (error) {\r\n\t\t\tresponse.writeHead(200);\r\n\t\t\tresponse.end('Authentication failed: ' + error.message);\r\n\t\t}\r\n\t\telse if (!authUrl) {\r\n\t\t\tresponse.writeHead(200);\r\n\t\t\tresponse.end('Authentication failed');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tresponse.writeHead(302, { Location: authUrl });\r\n\t\t\tresponse.end();\r\n\t\t}\r\n\t});\r\n});\r\n\r\napp.get('/login/verify', function(request, response) {\r\n\t// Verify identity assertion\r\n\t// NOTE: Passing just the URL is also possible\r\n\trelyingParty.verifyAssertion(request, function(error, result) {\r\n\t\tresponse.writeHead(200);\r\n\t\tresponse.end(!error && result.authenticated \r\n\t\t\t? 'Success :)' // TODO: redirect to something interesting!\r\n\t\t\t: 'Failure :('); // TODO: show some error message!\r\n\t});\r\n});"}